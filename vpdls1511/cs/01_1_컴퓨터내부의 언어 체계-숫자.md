> 해당 시리즈의 글은 “한 권으로 읽는 컴퓨터 구조와 프로그래밍” 에 나와있는 글의 내용과 유사하거나 똑같을 수 있으며, 잘못 이해하여 책에서 알려주는 내용과 차별점이 있을 수 있다는 점 양해 부탁드립니다.
> 

# 서론

 우리가 막 태어났을때 부모님께서 “엄마 해봐”, “아빠 해봐" 라는 말을 했을것이고, 시간이 지나 아이가 “ㅇ..어..엄..마..” 라고 했을 때 부모님들은 싱글벙글 웃으며 “그래그래 내가 엄마야!” 라고 하며 기뻐 하셨을 것이다. 이 후 성장을 하고 부모님과의 의사소통이 되며 부모님께서는 “이것좀 해봐" 라는 지시를 들으며 우리는 그걸 이행할 때도 있고, 상황에 따라 이행하지 않을때도 있다.

> 우리는 지시을 받을 때 “언어"라는 도구를 이용하여 이행할지 안할지 판단을 하게 된다. 컴퓨터도 비슷하다. 다만 이행하지 않는다는 선택지는 없다.
> 

 컴퓨터도 처음에는 그저 여러개의 기판으로 이루어진 그 자체였지만, 개발자가 컴퓨터의 언어로 컴퓨터에게 어떤 작업을 하라고 지시를 한다. 이 때 컴퓨터가 우리의 언어를 사용해서 소통을 한다면 정말 더할나위 없이 편하겠지만, **컴퓨터와의 의사소통은 단방향적이다**. 

 많은 개발자는 대부분 C와 Java같은 프로그래밍 언어로 컴퓨터와 소통하며 지시를 내린다. 하지만, **이 언어들이 과연 컴퓨터의 언어인가? 아니다. 그저 컴퓨터와 더욱 수월하게 소통하기 위한 수단**일 뿐이다. 컴퓨터 언어의 본질은 2진법이다.

## 2진법을 왜 알아야 할까

 우리가 처음 세상에 나와 사람을 대할 때 언어를 먼저 배우고 소통을 하듯 컴퓨터를 더 잘 이해하기 위해서는 컴퓨터의 언어를 알아야 한다. 이는 바로 2진법이다.

> 너무 당연한 이야기 이지만 우리는 컴퓨터와 소통하기 위해 Java나 C같은 프로그래밍 언어를 사용한다. 크게 문제가 없다고 사용하기 때문에 2진법은 그저 0과 1로 이루어진 것 이라고 알고 있다. 하지만 이러한 이유 때문이라면 우리가 사용하는 프로그래밍 언어를 통해서 소통을 하고 지시를 내리면 되는거 아닌가?
> 

이 질문이 생겨 왜? 알아야 할까 라는 생각을 가지고 더 조사를 해 보았다. 그 결과  **오류의 최소화와 효율성 때문**이라고 할 수 있다고 한다.

 오류의 최소화와 효율성이 무슨 소리일까? 바로 비용과 시간이다. 여기서 등장하는 개념이 바로 `비트플래그`인데 이에 관해서 깊게 다루지는 않고 가볍게 다루어 보도록 하자.

 가능/불가능 을 나눌 때 대표적으로 boolean을 사용하게 된다. 해당 자료형의 크기는 1btye 이며 이는 8bit 이다. 

`비트플래그`는 1bit이다 벌써 비트의 크기 차이가 8배나 난다는 것이다. 또 수 많은 값을 가능과 불가능으로 나누기 위해서 크기의 차이 만큼 속도도 오래 걸릴 수 있다. 컴퓨터의 자원이 무한하다면 boolean을 사용해도 괜찮지만 실제로 자원은 한정되어 있기 때문에 `비트플래그`를 이용하는 편이 훨씬 효율적이라고 볼 수 있다.

 그리고 이 비트플래그를 제대로 사용하려면 이 방법이 시작된 원점이자 컴퓨터의 언어인 2진법 즉, 비트를 알아야 한다.

# 본론

 이 글을 읽는 다른 사람들은 어떤지 모르겠지만, 필자는 이제서야 왜 알아야 하는지 감을 잡고 본론으로 들어가 제대로 공부하기 시작했다.

## 논리연산

논리 연산에는 기본적인 불리언 연산인 NOT, OR, AND 그리고 합성 연산인 XOR 이렇게 총 4개가 존재한다.

NOT - 논리적 반대를 뜻하는 해당 연산자 이다. 즉, 참을 거짓으로 만들고 거짓을 참으로 만든다.

OR - 둘 이상의 비트에 적용되며 둘 이상의 비트중 한 개만 참이어도 참이라는 결과를 나타낸다.

AND - 둘 이상의 비트에 적용되며 둘 이상의 비트가 모두 참이어야 참이라는 결과를 나타낸다.

XOR - 이는 eXclusive OR로 배타적 OR이라는 뜻을 가지고 있다. 첫 번째와 두 번째 결과중 한 가지만 참일 때 참이라는 결과를 나타내며, 둘 다 거짓이거나 참이면 거짓 이라는 결과를 나타낸다.

### 드모르간의 법칙

불리언 대수에 적용할 수 있는 새로운 법칙을 추가로 알아내어 생긴 법칙이다.
a AND b 는 둘 다 참일 때 참을 출력하는 연산인데, 이는 NOT(NOT a OR NOT b) 라고도 할 수 있다는 규칙을 알아냈다.

## 정수를 비트로 표현하는 방법

정수는 양의 정수와 음의 정수로 나뉘어진다.

흔히 우리가 0010 이라고 하면 2라고 나올 수 있다. 하지만, 이는 양의 정수이며 음의 정수는 어떻게 나타낼까?

### 음의 정수 표현

음의 정수는 부호 즉, Sign을 통해서 구별하게된다.

0 0010 이라 하면 2이다. 하지만, 1 0010이라 함은 -2 이다. 음의 정수 표현은 정말 간단하다.

### 이진수의 덧셈

이는 어렵지 않다. 흔히 우리가 10진수에서 덧셈을 할 때 아래와같은 공식을 사용할 것이다.
11 + 9를 보자. 우리는 이 식을 보고 바로 일의 자리 숫자가 1 + 9 = 10이므로 다음 자리인 십의자리에 1을 더할것이다.

이진수도 똑같다. 001 + 001 을 하면 어떻게 될까? 이도 똑같다 맨 오른쪽의 수가 1을 넘어가면 다음 자리에 1을 더한다. 즉, 위 식의 값은 010이며 십진수로 변환하면 2이다.

## 실수를 비트로 표현하는 방법

10진수인 0.3을 이진수로 표현을 하면 어떻게 될까?

0.010011001100110011………… 이런식으로 계속 증가를 하게 될 것이다. 이렇게 이진수로의 표현이 한계가 있어 컴퓨터는 근사치를 저장한다.

이 방법으 은 두가지가 있다.

### 고정 소수점

고정 소수점 표현법은 소수점의 위치가 항상 일정하기 때문에 고정소수점 표현이라고 한다.
자, 그럼 이 고정소수점 표현법은 어떻게 나뉘어 질까?

일단 소수점을 기준으로 왼쪽은 정수부분, 오른쪽은 지수부분이다.

만약, 11.01 이라 한다면 왼쪽은 기존의 정수를 비트로 표현하는 방법과 다르지 않지만, 우측의 경우 네가지 값만 표현할 수 있기 때문에 3과 1/4이다

이러한 접근 방법이 잘 작동하기는 하지만, 실수값을 표현하기 위한 비트값이 너무나도 많이 필요하기 때문에 범용적으로 사용되는 컴퓨터에 사용하기에는 무리가 있다.

### 부동 소수점

고정 소수점은 넓은 범위의 계산을 이진법으로 하기에는 무리가 있어 부동소수점 표기법을 고안해 냈다.

표현 방식은 각각 다를 수 있지만, 일반적으로는 IEEE에서 표준으로 제안한 방식을 사용합니다.

> **왜?** → 표현하는 방식이 부동소수점을 정하는 방식에 따라 다르기 때문에, IEEE에서 표준을 정하여 표현이 다르지 않게 하기 위함
> 

IEEE 부동소수점 수 표현 중 두 가지의 표현이 가장 많이 쓰인다.

- **기본 정밀도**
    - 이는 32비트를 사용하며 1비트의 부호비트 7비트의 지수, 23비트의 가수비트를 사용한다.
- **2배 정밀도**
    - 이는 64비트를 사용하며 기본 정밀도와 부호비트의 수는 같지만, 지수와 가수 비트의 크기가 증가한다.
    - 가수의 범위가 상위 20비트화 하위 32비트로 나뉘며 지수는 11비트 부호는 1비트 이다.

## BCD

과거에는 BCD라는 2진 표현법이 존재했다. 10진수 12를 2진수로 변환을 하게 된다면 일반적으로는 1100이다. 하지만, BCD는 십의자리와 일의자리를 나눈다. 0001 0010 처럼 말이다.

10진수에 더 친근한 우리는 이 방식이 더 친근하지만, BCD는 보이는것 처럼 비트의 낭비가 심하다.

## 2진수를 다루는 쉬운 방법

2진수는 솔직히 머리가 아프다 0과 1로만 이루어져 있어 눈이 빠질거같다. 1이 연속으로 붙어있으면 몇개인지 보기도 힘들고.. 그래서 이를 더 쉽게 읽을 수 있는 여러 방법들이 고안되어 나오게 되었다.

- 8진 표현법
- 16진 표현법

## 비트 그룹의 이름

우리가 돈을 셀 때 백원짜리가 10개 있다고 해서 십백원이라고 하지않고 천원 이라고 한다.
이렇게 비트도 여러개가 묶였을 때의 이름이 있다.

> 니블(nibble) / 4bit
바이트(byte) / 8bit
하프 워드(harf word) / 16bit
워드(word) / 32bit
더블워드(double word) / 64bit
> 

word는 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가리키는 말로 쓰인다. 여기서 자연스럽다는 말은 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리라는 뜻 이다.

# 결론

나중에 아는척좀 해봐야겠다 :) 우리집 윈도우는 더블워드야!
